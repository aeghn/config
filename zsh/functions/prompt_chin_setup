# Chin prompt theme

# Reference:
#     Overall: http://zsh.sourceforge.net/Doc/Release/Shell-Builtin-Commands.html
#     zsh/zselect: http://zsh.sourceforge.net/Doc/Release/Zsh-Modules.html#The-zsh_002fzselect-Module
#     coproc: https://unix.stackexchange.com/questions/86270/how-do-you-use-the-command-coproc-in-various-shells
#             https://www.zsh.org/mla/users/2011/msg00095.html

# Thanks to: https://github.com/ericfreese/zsh-efgit-prompt/blob/master/prompt_efgit_setup

## Basic prompt parts
prompt_chin_head() {
    setopt localoptions noxtrace nowarncreateglobal
    local pr_error pr_back pr_name pr_dir

    pr_state='%(?..%F{red}[%?]%f )'  # the last function return code
    pr_bgpg='%(1j.%F{cyan}(%j)%f .)' # background program
    pr_host='%B%F{blue}%m%f%b'
    pr_dir='%B%F{green}%~%f%b'
    pr_name='%B%F{yellow}%n%f%b'

    printf  "%s"  "${pr_state}${pr_bgpg}${pr_name} at ${pr_host} in ${pr_dir}"
}

prompt_chin_tail() {
    setopt localoptions noxtrace nowarncreateglobal
    local pr_prompt pr_post

    pr_prompt='%F{red}%(!,%K{red}#%k,$) '
    pr_post='%b%f%k'

    echo "${prompt_newline}${pr_prompt}${pr_post}"
}

## Extended prompt part: git
prompt_chin_git_status() {
    local work_dir="$PWD"
    git rev-parse --git-dir >&- 2>&- || {
        echo -n $'\0'
        return
    }

    local -a parts
    local fd line head ahead behind conflicts staged changed untracked

    exec {fd}< <(git status --porcelain=v2 --branch)

    while read -A -u $fd line; do
        case "$line" in
            '# branch.head'*) # Current branch
                head="$line[3]"
                [[ $head == "(detached)" ]] && head="$(echo ":$(git rev-parse --short HEAD)")"
                ;;
            '# branch.ab'*) # Divergence from upstream
                ahead="${line[3]/#+}"
                behind="${line[4]/#-}"
                ;;
            [12]*) # Modified or renamed/copied
                [[ "${${line[2]}[1]}" != "." ]] && ((staged++))
                [[ "${${line[2]}[2]}" != "." ]] && ((changed++))
                ;;
            'u'*) # Unmerged
                ((conflicts++))
                ;;
            '?'*) # Untracked
                ((untracked++))
                ;;
        esac
    done

    exec {fd}<&-

    parts+="on git: $head"

    local -a upstream_divergence

    [[ $ahead > 0 ]] && upstream_divergence+="%F{blue} A$ahead%f"
    [[ $behind > 0 ]] && upstream_divergence+="%F{blue} B$behind%f"

    if [[ $#upstream_divergence > 0 ]]; then
        parts+="${(j::)upstream_divergence}"
    fi

    local -a working_info

    [[ $conflicts > 0 ]] && working_info+="%F{red} x$conflicts%f"
    [[ $staged > 0 ]] && working_info+="%F{green} s$staged%f"
    [[ $changed > 0 ]] && working_info+="%F{208} *$changed%f"
    [[ $untracked > 0 ]] && working_info+="%F{red} +$untracked%f"

    if [[ $#working_info > 0 ]]; then
        parts+="${(j::)working_info}"
    else
        parts+=" %F{green}o%f"
    fi

    if [ "$PWD" = "$work_dir" ]; then
       echo -n "${(j::)parts}"
    fi
}

prompt_chin_git_assemble() {
    typeset -g PROMPT_CHIN_GIT_STATUS

    PROMPT_CHIN_GIT_STATUS="$(<&$1)"
    [ -n "$PROMPT_CHIN_GIT_STATUS" ] || return
    PROMPT="${PROMPT_CHIN_HEAD} ${PROMPT_CHIN_GIT_STATUS}${PROMPT_CHIN_TAIL}"
    zle reset-prompt

    zle -F $1
    exec {1}<&-
}


prompt_chin_extend() {
    typeset -g PROMPT_CHIN_GIT_FD

    # Close previous fd
    # [[ -n $PROMPT_CHIN_GIT_FD ]] && {
    # zle -F $PROMPT_CHIN_GIT_FD
    # exec {PROMPT_CHIN_GIT_FD}<&-
    # }

    exec {PROMPT_CHIN_GIT_FD}< <(prompt_chin_git_status)
    zle -F $PROMPT_CHIN_GIT_FD prompt_chin_git_assemble

    # unset PROMPT_CHIN_HEAD PROMPT_CHIN_TAIL PROMPT_CHIN_GIT_STATUS PROMPT_CHIN_GIT_FD
}

prompt_chin_precmd() {
    typeset -g PROMPT_CHIN_HEAD PROMPT_CHIN_TAIL

    PROMPT_CHIN_HEAD="$(prompt_chin_head)"
    PROMPT_CHIN_TAIL="$(prompt_chin_tail)"

    PROMPT="${PROMPT_CHIN_HEAD}${PROMPT_CHIN_TAIL}"

    prompt_chin_extend
}

add-zsh-hook precmd prompt_chin_precmd
